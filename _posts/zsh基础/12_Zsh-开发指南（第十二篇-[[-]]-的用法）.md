## 导读

[[ ]] 是我们比较熟悉的符号了，从第一篇开始我们就一直在用，但我一直没有详细介绍它的用法，只用到了它的一小部分功能。本文详细介绍 [[ ]] 的用法。

## 比较字符串

[[ ]] 最常用的功能之一是比较字符串，这也是我们一直在用的功能。

```
# 匹配
% [[ abc == abc ]] && echo good
good

# = 和 == 是一样的，最好统一使用一种
% [[ abc = abc ]] && echo good
good

# 不匹配
% [[ abc != abd ]] && echo good
good

# 正则表达式匹配
% [[ abc =~ a.c ]] && echo good
good

# 前者字符序比后者小
% [[ abc < bcd ]] && echo good
good

# 前者字符序比后者大
% [[ cde > bcd ]] && echo good
good

# 没有 >= 和 <=
% [[ cde >= bcd ]] && echo good
zsh: parse error near `bcd'
```

除了在里边用等号、不等号之类比较外，还可以判断字符串是否为空：

```
% str=abc
# 判断字符串内容长度是否大于 0，等同于 (($#str))
% [[ -n $str ]] && echo good
good

% str=""
# 判断字符串是否为空，等同于 ((! $#str))
% [[ -z $str ]] && echo good
good
```

但这两种用法，我们都有更方便的其他实现方法，没有必要用它们。

## 判断文件

[[ ]] 另一类很重要的功能是判断文件，比如判断某一个文件是否存在、是否是目录、是否可读等等。

判断 /bin/zsh 文件是否存在：

```
% [[ -e /bin/zsh ]] && echo good
good
% [[ -e /bin/zshh ]] && echo good

```

-e 可以替换成如下的选项，用法是一致的：

| 选项   | 符合条件的文件                          |
| ---- | -------------------------------- |
| -b   | 块设备文件                            |
| -c   | 字符设备文件                           |
| -d   | 目录                               |
| -e   | 存在的任何文件                          |
| -f   | 普通文件，含符号链接，不含目录、设备文件、socket、FIFO |
| -g   | 设置了 setgid 的文件                   |
| -h   | 符号链接                             |
| -k   | 设置了粘滞位（sticky bit）的文件            |
| -p   | FIFO 文件                          |
| -r   | 对当前进程可读的文件                       |
| -s   | 非空文件                             |
| -u   | 设置了 setuid 的文件                   |
| -x   | 对当前进程可执行的文件                      |
| -w   | 对当前进程可写的文件                       |
| -L   | 符号链接（同 -h）                       |
| -O   | 被当前进程的用户拥有的文件                    |
| -G   | 被当前进程的用户组拥有的文件                   |
| -S   | socket 文件                        |
| -N   | atime 和 mtime 一样的文件              |

还有一个比较特殊的 -t 选项：

```
# $$ 是当前的进程 id
% ls /proc/$$/fd
0  1  10  11  2
% [[ -t 10 ]] && echo good
good
% [[ -t 3 ]] && echo good

```

-t 后要接数字（如果不是，相当于 0），判断当前进程是否打开了对应的 fd（进程默认会打开 0、1、2 这三个 fd，分别对应标准输入、标准输出和错误输出，此外每打开一个文件、管道或者网络连接，都会对应一个 fd，关掉后对应 fd 会消失）。

## 比较文件

除了判断单个文件是否符合条件外，[[ ]] 还可以用来比较两个文件。

```
# file1 比 file2 新
% [[ file1 -nt file2 ]]

# file1 比 file2 旧
% [[ file1 -ot file2 ]]

# file1 和 file2 是否对应同一个文件（路径相同或者互为硬连接）
% [[ file1 -ef file2 ]]
```

## 比较数值

[[ ]] 也可以用来比较数值，注意不是用等号、大于号、小于号等等比较，有一系列专门的符号。通常我们没必要用 [[ ]] 来比较数值，用 (( )) 更方便一些。

```
# -eq 是判断两个数值是否相等
% [[ 12 -eq 12 ]] && echo good
good
```

-eq 可以替换成下列符号，用法一样：

| 符号   | 含义   |
| ---- | ---- |
| -eq  | 相等   |
| -ne  | 不相等  |
| -lt  | <    |
| -gt  | >    |
| -le  | <=   |
| -ge  | >=   |

## 组合使用

```
# && 是逻辑与
% [[ a == a && b == b ]] && echo good
good

# || 是逻辑或
%  [[ a == a || a == b ]] && echo good
good

# ! 是逻辑非
% [[ ! a == b ]] && echo good
good

# 可以一起用，! 优先级最高，其次 &&，再次 ||
% [[ ! a == b && b == a || b == b ]] && echo good
good

# 如果不确定优先级，可以加小括号
% [[ ((! a == b) && b == a) || b == b ]] && echo good
good
```

需要注意一下空格，[[ ]] 内侧和内容之间需要空格隔开，== 两边也需要空格。如果是在 zsh 中直接敲入，! 后边也要加一个空格，不然会被解析成历史命令。

## [ ] 符号

除了 [[ ]] 符号，[ ] 符号（它是古老的 test 命令化身）也可以用来判断字符串、文件、数值等等，但功能没有 [[ ]] 全，只支持上边列的一部分功能（不支持 ==、=~、>、<、(、) ，并且逻辑与或的语法不一样，不能调整优先级，用起来很不方便），通常没有必要使用 [ ]（如需使用，可以 man test 查看用法）。

## 总结

本文详细介绍了 [[ ]] 的用法，基本覆盖全面了。

## 参考

http://www.bash2zsh.com/zsh_refcard/refcard.pdf
